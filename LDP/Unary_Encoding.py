import numpy as np
import random
import math
import numbers

class Unary_Encoding_client():
	def __init__(self, e, d, optimized=True, p=0, q=0):
		# initialization of the protocol's constants
		self.d = d
		self.p = p
		self.q = q
		self.e = e
		self.optimized = optimized
		# if the user wants OUE, we initialize p and q 
		# according to the theory, and based on epsilon
		if self.optimized:
			self.p = 1 / 2 
			self.q = 1 / (math.exp(self.e) + 1)
		
	# encoding consists of creating a d-bit vetor, where
	# only the v-th element is 1, and every other equal to 0
	def encode(self, v):
		assert(v < self.d)
		B = np.zeros(self.d)
		B[v] = 1
		return B
	
	# perturbation consists of setting each bit of the array
	# to 0 or 1, according to the probabilities defined as 
	# features of the protocol
	def perturb(self, ret):
		B = ret

		perturb_B = B
		# for each bit of the binary array
		for i in range(len(B)):
    		# depending on wether it is 0 or 1
			if B[i] == 1:
				pr = self.p
			else: 
				pr = self.q
			# generate a random number
			res = random.random()
			# in order to determine the bit in the new array
			if res < pr:
				perturb_B[i] = 1
			else:
				perturb_B[i] = 0
		
		return perturb_B

	# randomization consists of perturbing the encoded value
	def randomize(self, v):
		return self.perturb(self.encode(v))
	
	def aggregate(self, config):
		# define the needed variables from the configuration dict provided
		reported_values = config['reported_values']
		d = config['d']

		p = self.p
		q = self.q

		# array to store the results
		results = np.zeros(d)
		n = len(reported_values)
		

		# compute the estimation for each value of the domain
		for i in range(d):
			sum_v = 0
			for j in reported_values:
    			# Support(i) = {i | B[i] == 1}, thus the protocol supports only 
				# the values that have 1 on the v-th bit of their matrix
				if j[i] == 1:
					sum_v += 1
			# normalize the sum by trying to extract the noise
			results[i] = ((sum_v) - n * q) / (p - q)
			# if a negative sum is generated by the normalization, convert it to zero
			if (results[i] < 0):
				results[i] = 0

		return results

class Unary_Encoding_aggregator():
	def __init__(self, e, d, optimized=True, p=0, q=0):
		# initialization of the protocol's constants
		self.d = d
		self.p = p
		self.q = q
		self.e = e
		self.optimized = optimized
		# if the user wants OUE, we initialize p and q 
		# according to the theory, and based on epsilon
		if self.optimized:
			self.p = 1 / 2 
			self.q = 1 / (math.exp(self.e) + 1)
	
	def aggregate(self, config):
		# define the needed variables from the configuration dict provided
		reported_values = config['reported_values']
		d = config['d']

		p = self.p
		q = self.q

		# array to store the results
		results = np.zeros(d)
		n = len(reported_values)
		

		# compute the estimation for each value of the domain
		for i in range(d):
			sum_v = 0
			for j in reported_values:
    			# Support(i) = {i | B[i] == 1}, thus the protocol supports only 
				# the values that have 1 on the v-th bit of their matrix
				if j[i] == 1:
					sum_v += 1
			# normalize the sum by trying to extract the noise
			results[i] = ((sum_v) - n * q) / (p - q)

		return results
